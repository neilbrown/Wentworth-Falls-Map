#!bin/nash

osm=$1

{
sed '/^<.osm>$/d' $osm
gawk '
	function abbrev_way(name)
	{
		sub(/Avenue$/,"Ave", name)
		sub(/Circle$/,"Cir", name)
		sub(/Close$/, "Cl", name)
		sub(/Crescent$/, "Cr", name)
		sub(/Drive$/, "Dr", name)
		sub(/Grove$/, "Gr", name)
		sub(/Highway$/, "Hwy", name)
		sub(/Lane$/, "Ln", name)
		sub(/Parade$/, "Pde", name)
		sub(/Place$/, "Pl", name)
		sub(/Road$/, "Rd", name)
		sub(/Street$/, "St", name)
		sub(/Circuit$/, "Cct", name)
		sub(/Arcade$/, "Arc", name)
		sub(/Track$/, "Trk", name)
		sub(/Plaza$/, "Plz", name)
		return name
	}

	function abs(a)
	{
		if (a < 0) return -a
		return a
	}

	function reverse(w, new,      i, l)
	{
		split("", new)
		l = length(w)
		for (i = 0; i < l ; i++)
			new[l-i-1] = w[i]
	}

	function canjoin(w1, w2, approx)
	{
		if (w1[length(w1)-1] == w2[0])
			return 1
		if (!approx)
			return 0

		r1a = w1[0]
		r1 = w1[length(w1)-1]
		r2 = w2[0]
		r2a = w2[length(w2)-1]
		if (abs(lon[r1]-lon[r2]) > 0.0006 ||
		    abs(lat[r1]-lat[r2]) > 0.0006)
			return 0
		# order must be roughly r1a r1 r2 r2a in some direction.
		if (((lat[r1a] <= lat[r1] && lat[r2] <= lat[r2a]) ||
		     (lat[r1a] >= lat[r1] && lat[r2] >= lat[r2a])) &&
		    ((lon[r1a] <= lon[r1] && lon[r2] <= lon[r2a]) ||
		     (lon[r1a] >= lon[r1] && lon[r2] >= lon[r2a])))
			return 1
		return 0
	}
	function dojoin_after(w1, w2,    i, l)
	{
		l = length(w1)
		for (i = 0; i < length(w2); i++)
			w1[l+i] = w2[i]
	}

	function dojoin_before(w1, w2,    i, l, l2)
	{
		# insert w1 before w2 - shifting w2 up
		l = length(w1)
		l2 = length(w2)
		for (i = l2; i > 0 ; i--)
			w2[l+i-1] = w2[i-1]
		for (i = 0; i < l; i++)
			w2[i] = w1[i]
	}

	function join2ways(ways, w1, w2, w1f, w2f, approx,    w1r, w2r)
	{
		if (w1 == w2)
			return 0
		reverse(w1f, w1r)
		reverse(w2f, w2r)

		if (canjoin(w1f,w2f, approx))
			dojoin_after(w1f,w2f)
		else if (canjoin(w1f,w2r, approx))
			dojoin_after(w1f, w2r)
		else if (canjoin(w1r,w2f, approx))
			dojoin_before(w2r, w1f)
		else if (canjoin(w1r, w2r, approx))
			dojoin_before(w2f, w1f)
		else
			return 0
		delete idrefs[w2]
		delete ways[w2]
		return 1
	}
	function join_ways(ways, approx)
	{
		retry = 1
		while (length(ways) > 1 && retry) {
			retry = 0
			for (id in ways) {
				for (id2 in ways) {
					if (join2ways(ways, id, id2, idrefs[id], idrefs[id2], approx)) {
						retry = 1
						break
					}
				}
				if (retry) break
			}
		}
	}

	function calc_way_len(id,    len, i, p0, p1, lt, ln)
	{
		len = 0
		p0 = idrefs[id][0]
		for (i = 1; i < length(idrefs[id]); i++) {	
			p1 = idrefs[id][i]
			lt = projection * 1000 * attenuation * (lat[p1] - lat[p0])
			ln = 1000 * attenuation * (lon[p1] - lon[p0])
			len += sqrt(lt*lt + ln*ln)
			p0 = p1
		}
		return len
	}

	function shares_point(p1, p2,    i, j)
	{
		for (i = 0; i < length(p1); i++)
			for (j = 0 ; j < length(p2); j++)
				if (p1[i] == p2[j])
					return 1
		return 0
	}

	BEGIN {
		prio["trunk"] = 1
		prio["secondary"] = 3
		prio["tertiary"] = 4
		prio["residential"] = 5
		prio["service"] = 6
		prio["track"] = 7
		prio["unclassified"] = 8
		# These are hidden
		prio["proposed"] = 99
		prio["trunk_link"] = 99
		prio["secondary_link"] = 99

		attenuation = 7
		# projection is 1/cos(latitude)
		projection = 1 / cos(-33.7 * 3.1415926 / 180.0)
	}

	$1 == "<node" && $3 ~ /lat=/ {
		split($0, ll, /"/);
		lon[ll[2]] = ll[6];
		lat[ll[2]] = ll[4];
	}
	$1 == "<way" {inway = 1; delete refs; hwy="";
		split($2, ids, /"/); id=ids[2];
		}
	$1 == "</way>" {
		n = name
		h = hwy
		fr = firstref
		lr = lastref

		inway = 0;
		name = "";
		hwy = "";
		firstref = ""

		if (!n || ! h || !fr)
			#nothing here...
			next;
		if (prio[h] == 99)
			next;

		for (i in refs)
			idrefs[id][i] = refs[i];

		ways[n][id] = 1;


		if (h in prio && n in hwyof && prio[h] > prio[hwyof[n]]) h = hwyof[n];
		if (prio[h] > 5) h = "residential"
		hwyof[n] = h
	}
			
	inway { split($0, wd, /"/) }
	inway && wd[2] == "name" { name = wd[4] }
	inway && wd[2] == "highway" { hwy = wd[4] }
	inway && wd[2] == "waterway" { hwy = "WATER" wd[4] }

	inway && wd[1] ~ "<nd ref=" { refs[length(refs)] = wd[2]; lastref=wd[2]; if (!firstref) firstref=wd[2]; }

	END {
		for (n in ways) {
			# attempt to join adjoining ways
			join_ways(ways[n], 0)
			# now try adjacent ways
			join_ways(ways[n], 1)

			for (id in ways[n]) {
				wlen = calc_way_len(id)
				alias = n
				if (wlen < length(alias))
					alias = abbrev_way(alias)
				if (wlen <= 0.70 * length(alias)) {
					# This name will not fit.  First see if there is a longer
					# path that shares a point.  If so, do not bother
					found = 0
					for (id2 in ways[n]) {
						if (id == id2)
							continue
						if (calc_way_len(id2) < wlen)
							continue
						if (shares_point(idrefs[id], idrefs[id2])) {
							found = 1
							break
						}
					}
					if (found)
						continue
					split(alias, awords)
					if (wlen > 4 && length(awords) > 1) {
						# Try to abbreviate.
						t = awords[length(awords)]
						l = length(alias) - length(t) + 1
						awords[length(awords)] = substr(t, 1, 1)
						mn = (l - (wlen/0.75)) / (length(awords)-1)
						mr = (l - (wlen/0.75)) - (mn * (length(awords)-1))
						# need to remove mn from all and 1 more from mr
						na = ""
						for (i = 1; i <= length(awords)-1; i++) {
							awords[i] = substr(awords[i], 1, length(awords[i])-mn)
							if (i <= mr)
								awords[i] = substr(awords[i], 1, length(awords[i])-1)
							na = na  awords[i] " "
						}
						na = na awords[length(awords)]
						alias = na
						printf "Shortened %s to %s\n", n, alias > "/dev/stderr"
					} else {
						printf "Len %s %s is %f\n", alias, id, calc_way_len(id) > "/dev/stderr"
						continue
					}
				}
				printf "<way id=\"A%s\">\n", id;
				for (i in idrefs[id]) {
					printf "  <nd ref=\"%s\"/>\n", idrefs[id][i]
				}
				if (substr(hwyof[n], 1, 5) == "WATER")
					printf "  <tag k=\"waterway\" v=\"%s_name\"/>\n", substr(hwyof[n], 6);
				else
					printf "  <tag k=\"highway\" v=\"%s_name\"/>\n", hwyof[n];

				printf "  <tag k=\"name\" v=\"%s\"/>\n", alias
				printf "</way>\n"
			}
		}
	}
' $osm
echo "</osm>"
}
