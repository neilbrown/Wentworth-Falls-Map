#!bin/nash

osm=$1

{
sed '/^<.osm>$/d' $osm
gawk '
	function abbrev_way(name)
	{
		sub(/Avenue$/,"Ave", name)
		sub(/Circle$/,"Cir", name)
		sub(/Close$/, "Cl", name)
		sub(/Crescent$/, "Cr", name)
		sub(/Drive$/, "Dr", name)
		sub(/Grove$/, "Gr", name)
		sub(/Highway$/, "Hwy", name)
		sub(/Lane$/, "Ln", name)
		sub(/Parade$/, "Pde", name)
		sub(/Place$/, "Pl", name)
		sub(/Road$/, "Rd", name)
		sub(/Street$/, "St", name)
		return name
	}

	function abs(a)
	{
		if (a < 0) return -a
		return a
	}

	function reverse(w, new,      i, l)
	{
		split("", new)
		l = length(w)
		for (i = 0; i < l ; i++)
			new[l-i-1] = w[i]
	}

	function canjoin(w1, w2, approx)
	{
		if (w1[length(w1)-1] == w2[0])
			return 1
		if (!approx)
			return 0

		r1a = w1[0]
		r1 = w1[length(w1)-1]
		r2 = w2[0]
		r2a = w2[length(w2)-1]
		if (abs(lon[r1]-lon[r2]) > 0.0006 ||
		    abs(lat[r1]-lat[r2]) > 0.0006)
			return 0
		# order must be roughly r1a r1 r2 r2a in some direction.
		if (((lat[r1a] <= lat[r1] && lat[r2] <= lat[r2a]) ||
		     (lat[r1a] >= lat[r1] && lat[r2] >= lat[r2a])) &&
		    ((lon[r1a] <= lon[r1] && lon[r2] <= lon[r2a]) ||
		     (lon[r1a] >= lon[r1] && lon[r2] >= lon[r2a])))
			return 1
		return 0
	}
	function dojoin_after(w1, w2,    i, l)
	{
		l = length(w1)
		for (i = 0; i < length(w2); i++)
			w1[l+i] = w2[i]
	}

	function dojoin_before(w1, w2,    i, l, l2)
	{
		# insert w1 before w2 - shifting w2 up
		l = length(w1)
		l2 = length(w2)
		for (i = l2; i > 0 ; i--)
			w2[l+i-1] = w2[i-1]
		for (i = 0; i < l; i++)
			w2[i] = w1[i]
	}

	function join2ways(ways, w1, w2, w1f, w2f, approx,    w1r, w2r)
	{
		if (w1 == w2)
			return 0
		reverse(w1f, w1r)
		reverse(w2f, w2r)

		if (canjoin(w1f,w2f, approx))
			dojoin_after(w1f,w2f)
		else if (canjoin(w1f,w2r, approx))
			dojoin_after(w1f, w2r)
		else if (canjoin(w1r,w2f, approx))
			dojoin_before(w2r, w1f)
		else if (canjoin(w1r, w2r, approx))
			dojoin_before(w2f, w1f)
		else
			return 0
		delete idrefs[w2]
		delete ways[w2]
		return 1
	}
	function join_ways(ways, approx)
	{
		retry = 1
		while (length(ways) > 1 && retry) {
			retry = 0
			for (id in ways) {
				for (id2 in ways) {
					if (join2ways(ways, id, id2, idrefs[id], idrefs[id2], approx)) {
						retry = 1
						break
					}
				}
				if (retry) break
			}
		}
	}
	BEGIN {
		prio["trunk"] = 1
		prio["secondary"] = 3
		prio["tertiary"] = 4
		prio["residential"] = 5
		prio["service"] = 6
		prio["track"] = 7
		prio["unclassified"] = 8
		# These are hidden
		prio["proposed"] = 99
		prio["trunk_link"] = 99
		prio["secondary_link"] = 99
	}

	$1 == "<node" && $3 ~ /lat=/ {
		split($0, ll, /"/);
		lon[ll[2]] = ll[6];
		lat[ll[2]] = ll[4];
	}
	$1 == "<way" {inway = 1; delete refs; hwy="";
		split($2, ids, /"/); id=ids[2];
		}
	$1 == "</way>" {
		n = name
		h = hwy
		fr = firstref
		lr = lastref

		inway = 0;
		name = "";
		hwy = "";
		firstref = ""

		if (!n || ! h || !fr)
			#nothing here...
			next;
		if (prio[h] == 99)
			next;

		if (! (n in alias))
			alias[n] = abbrev_way(n)

		for (i in refs)
			idrefs[id][i] = refs[i];

		ways[n][id] = 1;


		if (h in prio && n in hwyof && prio[h] > prio[hwyof[n]]) h = hwyof[n];
		if (prio[h] > 5) h = "residential"
		hwyof[n] = h
	}
			
	inway { split($0, wd, /"/) }
	inway && wd[2] == "name" { name = wd[4] }
	inway && wd[2] == "highway" { hwy = wd[4] }

	inway && wd[1] ~ "<nd ref=" { refs[length(refs)] = wd[2]; lastref=wd[2]; if (!firstref) firstref=wd[2]; }

	END {
		for (n in ways) {
			# attempt to join adjoining ways
			join_ways(ways[n], 0)
			# now try adjacent ways
			join_ways(ways[n], 1)

			for (id in ways[n]) {
				printf "<way id=\"A%s\">\n", id;
				for (i in idrefs[id]) {
					printf "  <nd ref=\"%s\"/>\n", idrefs[id][i]
				}
				printf "  <tag k=\"highway\" v=\"%s_name\"/>\n", hwyof[n];

				printf "  <tag k=\"name\" v=\"%s\"/>\n", alias[n]
				printf "</way>\n"
			}
		}
	}
' $osm
echo "</osm>"
}
